<<includeIntrinsic>>

#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <string>
#include <cstdlib>
#include <fstream>
#include <string>
#include "faust/gui/APIUI.h"
#define FAUSTFLOAT float
using std::unordered_map;
using std::string;
using std::cout;
using std::cerr;
using std::endl;
using std::exit;
using std::ofstream;
using std::to_string;

class dsp {};

class MapMeta : public Meta, public unordered_map<string, string> {
public:
    void declare(const char* key, const char* value) {
        (*this)[key] = value;
    }
};

struct Soundfile {};

#define FAUST_ADDBUTTON(...)
#define FAUST_ADDCHECKBOX(...)
#define FAUST_ADDVERTICALSLIDER(...)
#define FAUST_ADDHORIZONTALSLIDER(...)
#define FAUST_ADDNUMENTRY(...)
#define FAUST_ADDVERTICALBARGRAPH(...)
#define FAUST_ADDHORIZONTALBARGRAPH(...)
#define FAUST_ADDSOUNDFILE(...)
#define FAUST_UIMACROS

<<includeclass>>

int main(int argc, char ** argv) {
    if (argc != 3) {
        cerr << "expected two output file names" << endl;
        exit(1);
    }

    ofstream inputs(argv[1]);
    ofstream manifest(argv[2]);

    // First produce the manifest file.
    MapMeta meta;
    APIUI ui;
    mydsp dsp;
    dsp.metadata(&meta);
    dsp.buildUserInterface(&ui);

    int max_param = 0;
    float mins[7], maxs[7];
    string tooltips[7];
    bool percents[7];

    for (int param = 1; param <= 6; param++) {
        string param_name = string("param") + to_string(param);
        int index = ui.getParamIndex(param_name.c_str());

        if (index == -1) {
            mins[param] = 0;
            maxs[param] = 0;
            tooltips[param] = "Unused";
            percents[param] = 0;
        } else {
            max_param = std::max(max_param, param);

            mins[param] = ui.getParamMin(index);
            maxs[param] = ui.getParamMax(index);
            string unit = ui.getMetadata(index, "scale");
            percents[param] = unit == "percent";
            string name = ui.getMetadata(index, "tooltip");
            if (name == "") name = string("Parameter ") + to_string(param);
            tooltips[param] = name;

            if (!percents[param]) {
                // The UI displays all parameter numbers increased by one
                mins[param]--;
                maxs[param]--;
                // But also values are not allowed to be negative
                if (mins[param] < 0) mins[param] = 0;
            }
        }
    }

    // The world's worst JSON emitter!
    int level = 0;
    #define INDENT for (int i = 0; i < level * 2; i++) manifest << ' ';
    #define TOKEN(x) manifest << (x);
    #define STRING(x) TOKEN('"') TOKEN(x) TOKEN('"')
    #define NL manifest << endl;
    #define OPEN TOKEN('{') level++; NL
    #define CLOSE level--; INDENT TOKEN('}')
    #define OPENSQ TOKEN('[') level++; NL
    #define CLOSESQ level--; INDENT TOKEN(']')
    #define KEY(x) INDENT STRING(#x) TOKEN(": ")
    #define NEXT TOKEN(',') NL

    OPEN KEY(header) OPEN
        KEY(platform) STRING("minilogue-xd") NEXT
        KEY(module) STRING("osc") NEXT
        KEY(api) STRING("1.1-0") NEXT
        KEY(dev_id) TOKEN(0) NEXT
        KEY(prg_id) TOKEN(0) NEXT
        KEY(version) STRING("1.0-0") NEXT
        KEY(name) STRING(meta.contains("name") ? meta["name"] : FAUST_FILE_NAME) NEXT
        KEY(num_param) TOKEN(max_param) NEXT
        KEY(params) OPENSQ
          for (int i = 1; i <= max_param; i++) {
              INDENT TOKEN('[')
              STRING(tooltips[i]) TOKEN(',')
              TOKEN(mins[i]) TOKEN(',')
              TOKEN(maxs[i]) TOKEN(',')
              STRING(percents[i] ? "%" : "")
              TOKEN(']')
              if (i == max_param) NL else NEXT
          }
        CLOSESQ NL
    CLOSE NL CLOSE NL

    // Now produce inputs.h. This is a file which defines macros for
    // sending new events to Faust - e.g. when a key is pressed.
    // If the user defines e.g.
    //   freq = hslider("freq", 100, 1, 20000, 1)
    // then the DSP class will contain a field e.g. fFreq, and then
    // inputs.h will contain a macro definition
    //   #define set_freq(val) dsp.fFreq = val.
    //
    // The relevant information largely comes from FAUST_LIST_ACTIVES.
    // One extra feature is that we auto-scale shape and shift-shape.
    // These natively have a range of 0..1, but if the user declares e.g.
    //   hslider("shape", 600, 150, 2000, 1)
    // then we will scale the range to 150...2000 instead. In this file,
    // all that we do is emit the min/max range of shape/shift-shape as
    // macro definitions - logue.arch takes care of the calculations.

    unordered_map<string, string> zone_vars;
    #define ADD_ACTIVE(kind, faustname, name, var, ...) zone_vars[name] = #var;
    FAUST_LIST_ACTIVES(ADD_ACTIVE)

    if (zone_vars.contains("vel") && !zone_vars.contains("velocity"))
        zone_vars["velocity"] = zone_vars["vel"];

    string names[] = {
        "key", "freq", "velocity", "gain", "gate",
        "shape", "shiftshape", "lfo", "cutoff", "resonance",
        "param1", "param2", "param3", "param4", "param5", "param6"
    };

    for (string name: names) {
        if (zone_vars.contains(name))
            inputs << "#define set_" << name << "(val) dsp." << zone_vars[name] << " = val" << endl;
        else
            inputs << "#define set_" << name << "(val)" << endl;
    }

    #define emit_shape_bounds(name, min_name, max_name) { \
        int index = ui.getParamIndex(name); \
        float min = 0, max = 0; \
        if (index != -1) { \
            min = ui.getParamMin(index); \
            max = ui.getParamMax(index); \
        } \
        inputs << "#define " << #min_name << " " << min << endl; \
        inputs << "#define " << #max_name << " " << max << endl; \
    }
    emit_shape_bounds("shape", SHAPE_MIN, SHAPE_MAX);
    emit_shape_bounds("shiftshape", SHIFTSHAPE_MIN, SHIFTSHAPE_MAX);
}
