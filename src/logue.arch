<<includeIntrinsic>>

#include <stdint.h>
#include <algorithm>
#include "userosc.h"
#include "inputs.h"
#include "utils/buffer_ops.h"
#define FAUSTFLOAT float

// Boilerplate

struct one_sample_dsp {
    one_sample_dsp(...) { }
};

struct Meta {
    void declare(const char* key, const char* value) {};
};

struct Soundfile {};

struct UI {
    void openTabBox(const char* label) {}
    void openHorizontalBox(const char* label) {}
    void openVerticalBox(const char* label) {}
    void closeBox() {}
    void addButton(const char* label, FAUSTFLOAT* zone) {}
    void addCheckButton(const char* label, FAUSTFLOAT* zone) {}
    void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
    void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
    void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
    void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) {}
    void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) {}
    void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) {}
    void declare(FAUSTFLOAT* zone, const char* key, const char* val) {}
};

// We need access to the slider values etc!
#define private public
<<includeclass>>
#undef private

mydsp dsp;
int iControl[FAUST_INT_CONTROLS];
float fControl[FAUST_REAL_CONTROLS];

#ifdef MONITOR_CPU_LOAD
#define DEMCR (volatile uint32_t* volatile) 0xe000edfc
#define DWT_CTRL (volatile uint32_t* volatile) 0xe0001000
#define DWT_CYCCNT (volatile uint32_t* volatile) 0xe0001004
#endif

#ifdef MONITOR_CPU_LOAD
uint32_t time = 0;
uint32_t busy_ticks = 0;
uint32_t start_tick = 0;
float cpu_usage = 0;
#define UPDATES_PER_SECOND 25
#define TICKS_PER_UPDATE (84000000/UPDATES_PER_SECOND)
#endif

void OSC_INIT(uint32_t platform, uint32_t api)
{
  (void)platform;
  (void)api;
  dsp.init(k_samplerate);

#ifdef MONITOR_CPU_LOAD
  *DEMCR |= 0x01000000;
  *DWT_CTRL |= 1;
  start_tick = *DWT_CYCCNT;
#endif
}

void OSC_CYCLE(const user_osc_param_t * const params,
               int32_t *yn,
               const uint32_t frames)
{
  // Update all parameters.
  // The pitchbending code comes from osc_w0f_for_note.
  uint8_t note = params->pitch >> 8;
  uint8_t mod = params->pitch & 0xff;
  float f0 = osc_notehzf(note);
  float f1 = osc_notehzf(note+1);
  float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

  set_key(note);
  set_freq(f);
  set_lfo(q31_to_f32(params->shape_lfo));
  set_cutoff((float)params->cutoff / 0x1fff);
  set_resonance((float)params->resonance / 0x1fff);

#if DOWNSAMPLE_FACTOR != 1 && DOWNSAMPLE_FACTOR != 2 && DOWNSAMPLE_FACTOR != 4
#error Downsampling can only be by a factor of 1, 2 or 4
#endif

  FAUSTFLOAT val_f32;

#ifdef MONITOR_CPU_LOAD
  uint32_t ticks_before = *DWT_CYCCNT;
  uint32_t total_ticks = ticks_before - start_tick;

  if (total_ticks >= TICKS_PER_UPDATE) {
    cpu_usage = (float)busy_ticks / total_ticks;
    start_tick = ticks_before;
    busy_ticks = 0;
  }
#endif

  dsp.control(iControl, fControl);
  for (unsigned i = 0; i < frames/DOWNSAMPLE_FACTOR; i++) {
    dsp.compute(0, &val_f32, iControl, fControl);

#ifdef MONITOR_CPU_LOAD
    volatile float dummy = val_f32;
#else
    q31_t val = f32_to_q31(val_f32);
    *yn++ = val;
#if DOWNSAMPLE_FACTOR >= 2
    *yn++ = val;
#endif
#if DOWNSAMPLE_FACTOR >= 4
    *yn++ = val;
    *yn++ = val;
#endif
#endif
  }

#ifdef MONITOR_CPU_LOAD
  uint32_t ticks_after = *DWT_CYCCNT;
  busy_ticks += ticks_after - ticks_before;

  float freq = 50 + cpu_usage*100;
  for (unsigned i = 0; i < frames; i++) {
    *yn++ = f32_to_q31(osc_sinf((float)time * freq / 48000));
    time++;
  }
#endif
}

void OSC_NOTEON(const user_osc_param_t * const params)
{
  // The API unfortunately doesn't report velocity.
  set_velocity(64);
  set_gain(0.5);
  set_gate(1);
  dsp.instanceClear(); // Makes some sense since the oscillator is monophonic
                       // and is paused when the ADSR envelope is at zero
}

void OSC_NOTEOFF(const user_osc_param_t * const params)
{
  set_velocity(0);
  set_gain(0);
  set_gate(0);
}

void OSC_PARAM(uint16_t index, uint16_t value)
{
  switch (index) {
  case k_user_osc_param_id1:
    set_param1(value);
    break;

  case k_user_osc_param_id2:
    set_param2(value);
    break;

  case k_user_osc_param_id3:
    set_param3(value);
    break;

  case k_user_osc_param_id4:
    set_param4(value);
    break;

  case k_user_osc_param_id5:
    set_param5(value);
    break;

  case k_user_osc_param_id6:
    set_param6(value);
    break;

  case k_user_osc_param_shape:
    set_shape(param_val_to_f32(value) * (SHAPE_MAX - SHAPE_MIN) + SHAPE_MIN);
    break;
    
  case k_user_osc_param_shiftshape:
    set_shiftshape(param_val_to_f32(value) * (SHIFTSHAPE_MAX - SHIFTSHAPE_MIN) + SHIFTSHAPE_MIN);
    break;
  }
}
