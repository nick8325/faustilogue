<<includeIntrinsic>>

#include <stdint.h>
#include <algorithm>
#include "userosc.h"
#include "inputs.h"
#include "utils/buffer_ops.h"
#define FAUSTFLOAT float

// Boilerplate

struct one_sample_dsp {
    one_sample_dsp(...) { }
};

struct Meta {
    void declare(const char* key, const char* value) {};
};

struct Soundfile {};

struct UI {
    void openTabBox(const char* label) {}
    void openHorizontalBox(const char* label) {}
    void openVerticalBox(const char* label) {}
    void closeBox() {}
    void addButton(const char* label, FAUSTFLOAT* zone) {}
    void addCheckButton(const char* label, FAUSTFLOAT* zone) {}
    void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
    void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
    void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
    void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) {}
    void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) {}
    void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) {}
    void declare(FAUSTFLOAT* zone, const char* key, const char* val) {}
};

// We need access to the slider values etc!
#define private public
<<includeclass>>
#undef private

mydsp dsp;
int iControl[FAUST_INT_CONTROLS];
float fControl[FAUST_REAL_CONTROLS];

void OSC_INIT(uint32_t platform, uint32_t api)
{
  (void)platform;
  (void)api;
  dsp.init(k_samplerate);
}

void OSC_CYCLE(const user_osc_param_t * const params,
               int32_t *yn,
               const uint32_t frames)
{
  // Update all parameters.
  // The pitchbending code comes from osc_w0f_for_note.
  uint8_t note = params->pitch >> 8;
  uint8_t mod = params->pitch & 0xff;
  float f0 = osc_notehzf(note);
  float f1 = osc_notehzf(note+1);
  float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

  set_key(note);
  set_freq(f);
  set_lfo(q31_to_f32(params->shape_lfo));
  set_cutoff((float)params->cutoff / 0x1fff);
  set_resonance((float)params->resonance / 0x1fff);

  // Do the computation on floats, then convert to q31.

#if SR_DIVIDER != 1 && SR_DIVIDER != 2 && SR_DIVIDER != 4
#error Sample rate must be 48, 24, or 12 kHz
#endif

  FAUSTFLOAT val_f32;

  dsp.control(iControl, fControl);
  for (unsigned i = 0; i < frames/SR_DIVIDER; i++) {
    dsp.compute(0, &val_f32, iControl, fControl);

    q31_t val = f32_to_q31(val_f32);
    *yn++ = val;
#if SR_DIVIDER >= 2
    *yn++ = val;
#endif
#if SR_DIVIDER >= 4
    *yn++ = val;
    *yn++ = val;
#endif
  }
}

void OSC_NOTEON(const user_osc_param_t * const params)
{
  // The API unfortunately doesn't report velocity.
  set_velocity(64);
  set_gain(0.5);
  set_gate(1);
  dsp.instanceClear(); // Makes some sense since the oscillator is monophonic
                       // and is paused when the ADSR envelope is at zero
}

void OSC_NOTEOFF(const user_osc_param_t * const params)
{
  set_velocity(0);
  set_gain(0);
  set_gate(0);
}

void OSC_PARAM(uint16_t index, uint16_t value)
{
  switch (index) {
  case k_user_osc_param_id1:
    set_param1(value);
    break;

  case k_user_osc_param_id2:
    set_param2(value);
    break;

  case k_user_osc_param_id3:
    set_param3(value);
    break;

  case k_user_osc_param_id4:
    set_param4(value);
    break;

  case k_user_osc_param_id5:
    set_param5(value);
    break;

  case k_user_osc_param_id6:
    set_param6(value);
    break;

  case k_user_osc_param_shape:
    set_shape(param_val_to_f32(value) * (SHAPE_MAX - SHAPE_MIN) + SHAPE_MIN);
    break;
    
  case k_user_osc_param_shiftshape:
    set_shiftshape(param_val_to_f32(value) * (SHIFTSHAPE_MAX - SHIFTSHAPE_MIN) + SHIFTSHAPE_MIN);
    break;
  }
}
